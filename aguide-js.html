<!DOCTYPE html>
<html>
<meta charset="iso-8859-1" />
<head>
  <title>aguide-js</title>
  <style>
    body {
        background-color: #d0d0d0;
    }

    .b {
        font-weight: bold;
    }

    .i {
        font-style: italic;
    }

    .u {
        text-decoration-line: underline;
    }

    .fg_text {
        color: black;
    }

    .fg_shine {
        color: white;
    }

    .fg_shadow {
        color: gray;
    }

    .fg_fill {
        color: gray;
    }

    .fg_filltext {
        color: black;
    }

    .fg_back {
        color: #d0d0d0;
    }

    .fg_highlight {
        color: white;
    }

    .bg_text {
        background-color: black;
    }

    .bg_shine {
        background-color: white;
    }

    .bg_shadow {
        background-color: gray;
    }

    .bg_fill {
        background-color: gray;
    }

    .bg_filltext {
        background-color: black;
    }

    .bg_back {
        background-color: #d0d0d0;
    }

    .bg_highlight {
        background-color: white;
    }

    input[type="file"] {
        display: none;
    }

    .button {
        /* border: 1px solid black; */
        /* display: inline-block; */
        /* padding: 6px 12px; */
        /* cursor: pointer;         */
    }

    div.toolbar {
        /* overflow: hidden; */
        position: fixed;
        background-color: #d0d0d0;
        width: 100%;
        height: 1.5em;
        top: 0;
        left: 0;
        padding: .5em;
        /* height: 20px; */
        /* border: 1px solid black; */
    }

    div.aguide {
        /* overflow: auto; */
        padding-top: 2em;
    }

  </style>
</head>
<body>

<div>
  <div class="toolbar">
    <!-- <label for="open-file" class="open-file button">Open</label> -->
    <input type="file" id="open-file"/>
    <button type="button" class="button" onclick="document.getElementById(&quot;open-file&quot;).click();">Open File...</button>
    <button type="button" class="button" id="button-contents" disabled="true">Contents</button>
    <button type="button" class="button" id="button-index" disabled="true">Index</button>
    <button type="button" class="button" id="button-help" disabled="true">Help</button>
    <button type="button" class="button" id="button-retrace" disabled="true" onclick="history.back()">Retrace</button>
    <button type="button" class="button" id="button-browse-prev" disabled="true">Browse &lt;</button>
    <button type="button" class="button" id="button-browse-next" disabled="true">Browse &gt;</button>
  </div>

  <div id="aguide" class="aguide">
    <p id="demo"></p>
  </div>
</div>

<script>
  function main()
  {
      var params = new URLSearchParams(window.location.search);
      var guideEnc = params.get("guide");
      if(guideEnc) {
          guide = decodeURI(guideEnc);
          console.log("guide = " + guide)
          if(guide.indexOf("http") === 0 || guide.indexOf("file") === 0) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", guide);
              xhr.responseType = "blob";
              xhr.onload = () => {
                  process_input(xhr.response);
              };
              xhr.send();
          }
      } else {
          const inputElement = document.getElementById("open-file");
          inputElement.addEventListener("change", read_input, false);
          inputElement.click();
      }

      addEventListener("popstate", handle_popstate);
      addEventListener("hashchange", display_node_hash);
  }

  function handle_popstate(event)
  {
      if(event.state && event.state.node === "main") {
          document.getElementById("button-retrace").disabled = true;
      } else {
          document.getElementById("button-retrace").disabled = false;
      }          
      display_node_hash();
  }

  function handle_click_link(event)
  {
      display_node_hash();
      document.getElementById("button-retrace").disabled = false;
      return true;
  }

  function read_input()
  {
      const file = this.files.item(0);
      var reader = new FileReader();
      reader.addEventListener("load", () => { process_input(reader.result); },
                              false);
      reader.readAsText(file);
  }

  var AG = null;

  function process_input(text)
  {
      var ps = new_tbuf(text);
      AG = parse_aguide(ps);

      var aguide_div = document.getElementById("aguide");
      aguide_div.addEventListener("onload", () => {alert("onload")});
      
      if(!AG) {
          aguide_div.innerHTML = "Input does not appear to be AmigaGuide";
          return;
      }
      
      var t = "Parsed an AmigaGuide ${AG.database}<br>";
      t += JSON.stringify(AG.nodes);
      console.info(t);

      var u = new URL(window.location);
      if(u.hash) {
          u.hash = "#";
          window.location = u.toString();
      }

      document.getElementById("button-retrace").disabled = true;

      if(AG.index) {
          document.getElementById("button-index").disabled = false;
          index_button.disabled = false;
      }

      set_button_link(document.getElementById("button-contents"),
                      find_toc(AG));

      history.replaceState({node: "main", ct: 0}, "main");
      display_node("main");
  }

  /******* amiga guide functions *******/
  function get_handler(handlers, name)
  {
      for(i = 0; i < handlers.length; ++i) {
          if(handlers[i].cmd === name) {
              return handlers[i].handler;
          }
      }

      return null;
  }

  function parse_aguide(ps)
  {
      var aguide = new_aguide(ps);

      if(!aguide) {
          return null;
      }

      const cmd_handlers = [
          { cmd: "@master", handler: finish_cmd_master },
          { cmd: "@node", handler: finish_cmd_node },
          { cmd: "@index", handler: finish_cmd_index },
          { cmd: "@remark", handler: finish_cmd_remark }
      ];

      var e = true;
      while(aguide && !at_eof(ps) && e === true) {
          var token = tbuf_search_token(ps, /^@\S+/m, false);
          if(!token) {
              break;
          }

          var t = token.token.toLowerCase();
          console.info("Parsed token: " + t);

          var cmd_handler = get_handler(cmd_handlers, t);
          if(cmd_handler) {
              e = cmd_handler(ps, token, aguide);
          }//  else {
          //     tbuf_consume_token(ps, token);
          // }
      }

      return aguide;
  }

  // Create a new aguide struct and parse the initial
  // `@database <name>` command
  function new_aguide(ps)
  {
      var token = get_next_token(ps, false);
      if(!token || token.token.toLowerCase() !== "@database") {
          return null;
      }

      console.info("Reading AmigaGuide: found @database");

      var db_name = get_next_token(ps, false);
      if(!db_name) {
          return null;
      }
      return {
          database: db_name.token,
          text: ps.text,
          nodes: []
      };
  }

  // token is @master, parse path
  // Return true on success, false on error
  function finish_cmd_master(ps, token, aguide)
  {
      var path = get_next_token(ps, false);
      if(!path) {
          return false;
      }
      aguide.master = path;
      console.info("  master.path = " + path);
      return true;
  }

  // token is @node, parse name, title, find @endnode
  function finish_cmd_node(ps, token, aguide)
  {
      var node = {
          name: "",
          title : "",
          start_cmd: token.start, // @ in @node
          start: -1,          // index past end of start
          end_cmd: -1,        // @ in @endnode
          end: -1             // index past end of @endnode
      };

      var name = get_next_token(ps, false);
      if(!name) {
          return false;
      }
      node.name = str_strip_quote(name.token.toLowerCase());

      console.log("node name " + node.name);

      var title = tbuf_search_token(ps, /$/m, false);
      if(title) {
          node.title = title.token;
      }
      node.start = title.end;

      var token = tbuf_search_token(ps, /^@endnode/mi, false);

      if(!token) {
          return false;
      }

      node.end = token.start;
      node.end_cmd = token.end;

      var en_name = get_next_token(ps, true);
      if(en_name && en_name.token.toLowerCase()[0] != "@") {
          tbuf_consume_token(ps, en_name);
          var n = en_name.token.toLowerCase();
          if(n !== node.name) {
              console.error("Found @endnode with name " + n + " for @node name " + node.name);
          } else {
              node.end_cmd = en_name.end;
          }
      }

      // tbuf_consume_to(ps.pos, ps2.pos);
      aguide.nodes.push(node);

      return true;
  }

  function finish_cmd_index(ps, token, aguide)
  {
      var index = get_next_token(ps, false);
      if(!index) {
          return false;
      }
      aguide.index = index;
      console.info("  index.node = " + index);
      return true;
  }

  function finish_cmd_remark(ps, token, aguide)
  {
      /* eat everything to end of line */
      var eol = tbuf_search_token(ps, /$/m, false);
      if(eol) {
          console.info("  remark: " + ps.text.slice(token.start, eol.end));
      }
      return true;
  }

  function find_node_index(aguide, name)
  {
      for(var i = 0; i < aguide.nodes.length; ++i) {
          if(aguide.nodes[i].name.toLowerCase() === name.toLowerCase()) {
              return i;
          }
      }

      return -1;
  }

  function find_node(aguide, name)
  {
      var i = find_node_index(aguide, name);
      if(i !== -1) {
          return aguide.nodes[i];
      }

      return null;
  }

  function find_toc(aguide)
  {
      if(aguide.toc) {
          return find_node(aguide, aguide.toc);
      }
      return find_node(aguide, "main");
  }

  function find_node_next(aguide, name)
  {
      var idx = find_node_index(aguide, name);
      var node = aguide.nodes[idx];
      if(node.next) {
          return node.next;
      } else if(idx + 1 < aguide.nodes.length) {
          return aguide.nodes[idx + 1];
      }
      return null;
  }

  function find_node_prev(aguide, name)
  {
      var idx = find_node_index(aguide, name);
      var node = aguide.nodes[idx];
      if(node.prev) {
          return node.prev;
      } else if(idx - 1 >= 0) {
          return aguide.nodes[idx - 1];
      }
      return null;
  }

  function display_node_hash()
  {
      var u = new URL(window.location)
      if(u.hash && u.hash[0] === "#") {
          display_node(u.hash.slice(1))
      } else {
          display_node("main")
      }
  }

  function set_contents(aguide, enabled)
  {
      let contents = document.getElementById("button-contents");
      if(enabled) {
          set_button_link(contents, find_toc(aguide));
          contents.disabled = false;
      } else {
          contents.disabled = true;
      }
  }

  function set_button_link(button, node)
  {
      if(!node) {
          button.disabled = true;
      } else {
          button.disabled = false;
          button.onclick = () => {
              window.location.hash = node.name;
          };
      }
  }

  /* Display node `name`, rendering to div with id 'aguide' */
  function display_node(name)
  {
      var n = find_node(AG, name);
      if(!n) {
          return;
      }

      html = render_html(AG, n);

      document.getElementById("button-contents").disabled =
          (name === find_toc(AG).name);

      set_button_link(document.getElementById("button-browse-next"),
                      find_node_next(AG, name));
      set_button_link(document.getElementById("button-browse-prev"),
                      find_node_prev(AG, name));

      var div = document.getElementById("aguide");
      div.innerHTML = html;
      // div.innerHTML = aguide.text.slice(n.start, n.end);
  }

  /* Translate amiga guide node to HTML */
  function render_html(aguide, node)
  {
      var html = "";

      var ps = new_node_tbuf(aguide, node);

      const cmd_handlers = [
      ];
   
      var ps2 = tbuf_translate(ps,
                               [{from: "<", to: "&lt;"},
                                {from: ">", to: "&gt;"},
                                {from: "\n", to: "<br>"}]);
      var render_state = {
          style: []
      };

      while(!at_eof(ps2)) {
          console.info("pos: " + ps2.pos);

          var c = tbuf_search_token(ps2, /[\\@]/, true);
          if(!c) {
              html += tbuf_slice(ps2, ps2.pos, -1, false);
              break;
          }

          html += tbuf_slice(ps2, 0, c.start - ps2.pos, false);

          if(c.token === "\\") { /* escape */
              /* Skip backslash, emit next char */
              html += tbuf_slice(ps2, 1, 2, false);
          } else if(c.token === "@") { /* start cmd */
              var brace = tbuf_search_token(ps2, /^@{[^}]*}/, true);
              if(brace) {
                  tbuf_consume_token(ps2, brace);
                  var cmd = brace.token.slice(2, -1);
                  console.log("handle @{" + cmd + "}");
                  html += render_brace_cmd(aguide, cmd, render_state);
              } else {
                  var t = get_next_token(ps2, false);
                  console.log("handle cmd " + t.token);
                  html += t.token;
              }
          }
      }

      // Convert any space chars at the beginning of a line to non-breaking
      html = html.replaceAll(/(<br>(?:<\/?span[^>]*>)*)( +)/gm,
                             (match, p1, p2, offset, string) => {
                                 var r = p1;
                                 for(var i = 0; i < p2.length; ++i) {
                                     r += "&nbsp;";
                                 }
                                 return r;
                             });

      return html;
  }

  function render_brace_cmd(aguide, cmd, render_state)
  {
      const orig = "@{" + cmd + "}"
      var ps = new_tbuf(cmd);
      var t = get_next_token(ps, false);
      if(!t) {
          return orig;
      }

      var tlc = t.token.toLowerCase();
      if(tlc === "b" || tlc === "i" || tlc === "u") {
          var html = render_state.style.length > 0 ? "</span>" : "";
          var cls = apply_style(render_state, tlc);
          if(cls) {
              html += "<span class=\"" + cls + "\">";
          }
          return html;
      } else if(tlc === "ub" || tlc === "ui" || tlc === "uu") {
          var html = render_state.style.length > 0 ? "</span>" : "";
          var cls = remove_style(render_state, tlc);
          if(cls) {
              html += "<span class=\"" + cls + "\">";
          }
          return html;
      } else if(tlc === "fg" || tlc === "bg") {
          var color = get_next_token(ps, false);
          if(color) {
              var html = render_state.style.length > 0 ? "</span>" : "";
              var cls = apply_color(render_state, tlc, color);
              if(cls) {
                  html += "<span class=\"" + cls + "\">";
              }
              return html;
          }
      } else {
          html = render_link(ps, t.token);
          if(!html) {
              return orig;
          }
          return html;
      }

      return orig;
  }

  function render_link(ps, link_text)
  {
      link_text = str_translate(link_text,
                                [{from: /^"/g, to: ""},
                                 {from: /"$/g, to: ""},
                                 {from: " ", to: "&nbsp;"}]);

      var t = get_next_token(ps, false);
      if(!t) {
          return null;
      }
      var command = t.token.toLowerCase();

      if(command === "link") {
          t = get_next_token(ps, false);
          if(!t) {
              return null;
          }
          var name = t.token;
          var line = "";

          t = get_next_token(ps, false);
          if(t) {
              line = t.token;
          }

          name = str_strip_quote(name)

          var m = name.match(/(.*)\/([^/]+)/);
          var link = "javascript:void(0);";
          if(m) {
              var file = m[1];
              var node = m[2];
          } else {
              link = "#" + name;
          }

          return "<a href=\"" + link + "\" onclick=\"handle_click_link();\">" + link_text + "</a>";
          <!-- return "<a href=\"#\" onclick=\"" + "foo(&quot;Bar&quot;);" + "\">" + link_text + "</a>"; -->
      }

      return null;
  }

  function foo(msg)
  {
      alert(msg);
  }

  function apply_style(render_state, cmd)
  {
      if(render_state.style.indexOf(cmd) === -1) {
          render_state.style.push(cmd);
          render_state.style.sort();
      }

      return render_state.style.join(" ");
  }

  function remove_style(render_state, cmd)
  {
      if(cmd[0] === "u") {
          render_state.style = render_state.style.filter((x) => {
              return x !== cmd[1];
          });
          render_state.style.sort();
      }

      return render_state.style.join(" ");
  }

  function apply_color(render_state, cmd, color)
  {
      render_state.style = render_state.style.filter((x) => {
          return x.indexOf(cmd) !== 0;
      });
      render_state.style.push(cmd + "_" + color.token);
      render_state.style.sort()

      return render_state.style.join(" ");
  }

  function new_node_tbuf(aguide, node)
  {
      return new_tbuf(aguide.text.slice(node.start, node.end));
  }

  /******* tbuf functions *******/
  function new_tbuf(text)
  {
      return { text: text, pos: 0 }
  }

  // function tbuf_dup(ps)
  // {
  //     return { text: ps.text, pos: ps.pos }
  // }

  function tbuf_fork(ps)
  {
      return new_tbuf(ps.text.slice(ps.pos))
  }

  function at_eof(ps)
  {
      return ps.pos >= ps.text.length
  }

  // peek: if true, don't update parse state
  function get_next_token(ps, peek)
  {
      var pos = ps.pos;

      // skip to first not-whitespace
      var next_ws = ps.text.slice(pos).search(/\S/);
      if(next_ws === -1) {
          return null;
      }

      pos += next_ws;

      var begins_line = false;
      if(pos > 0 && ps.text[pos - 1] == '\n') {
          begins_line = true;
      }

      var next_re = /\s/;
      var quoted = 0;
      // If current char is double quote, token is all text up to matching
      // quote.
      if(ps.text[pos] === '"') {
          next_re = /"/;
          quoted = 1;
      }

      var next = ps.text.slice(pos + quoted).search(next_re);
      if(next === -1) {
          /* token is all text to end */
          var token = ps.text.slice(pos);
          var end = pos + token.length;
          if(peek === false) {
              tbuf_consume_to(ps, end);
          }
          return new_token(token, pos, end, begins_line);
      }

      next += quoted * 2;
      var token = ps.text.slice(pos, pos + next);
      var end = pos + next;
      if(peek === false) {
          tbuf_consume_to(ps, end);
      }
      return new_token(token, pos, end, begins_line);
  }

  function new_token(token, start, end, begins_line)
  {
      return { token: token, start: start, end: end, begins_line: begins_line };
  }

  function tbuf_slice(ps, start, end, peek)
  {
      if(end !== -1) {
          var t = ps.text.slice(ps.pos + start, ps.pos + end);
          if(peek === false) {
              tbuf_consume_to(ps, ps.pos + end);
          }
          return t;
      }
      var t = ps.text.slice(ps.pos + start);
      if(peek === false) {
          tbuf_consume_to(ps, ps.text.length);
      }
      return t;
  }

  function tbuf_search_token(ps, re, peek)
  {
      var pos = ps.pos;
      var start = ps.text.slice(pos).search(re);
      if(start === -1) {
          return null;
      }

      var token = ps.text.slice(pos).match(re);
      if(token.length <= 0) {
          return null;
      }
      var end = pos + start + token[0].length;

      if(peek === false) {
          tbuf_consume_to(ps, end);
      }

      return new_token(token[0], pos + start, end, false);
  }

  function tbuf_consume_token(ps, token)
  {
      ps.pos = token.end;
  }

  // end: absolute position in tbuf to consume to
  function tbuf_consume_to(ps, end)
  {
      ps.pos = end;
  }

  // trs: array of objects {from: x, to: y}
  //      x: string or regex to replace
  //      y: replacement
  function tbuf_translate(ps, trs)
  {
      var ps2 = tbuf_fork(ps);
      ps2.text = str_translate(ps2.text, trs)
      return ps2;
  }

  function str_translate(s, trs)
  {
      trs.forEach((tr) => {
          s = s.replaceAll(tr.from, tr.to);
      });
      return s;
  }

  function str_strip_quote(s)
  {
      return str_translate(s, [{from: /^"/g, to: ""},
                               {from: /"$/g, to: ""}]);
  }

  main();
</script>

</body>
</html> 
