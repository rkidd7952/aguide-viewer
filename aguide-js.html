<!DOCTYPE html>
<html>
<meta charset="iso-8859-1" />
<head>
  <title>aguide-js</title>
  <style>
    body {
        background-color: #d0d0d0;
    }

    .b {
        font-weight: bold;
    }

    .i {
        font-style: italic;
    }

    .u {
        text-decoration-line: underline;
    }

    .fg_text {
        color: black;
    }

    .fg_shine {
        color: white;
    }

    .fg_shadow {
        color: gray;
    }

    .fg_fill {
        color: gray;
    }

    .fg_filltext {
        color: black;
    }

    .fg_back {
        color: #d0d0d0;
    }

    .fg_highlight {
        color: white;
    }

    .bg_text {
        background-color: black;
    }

    .bg_shine {
        background-color: white;
    }

    .bg_shadow {
        background-color: gray;
    }

    .bg_fill {
        background-color: gray;
    }

    .bg_filltext {
        background-color: black;
    }

    .bg_back {
        background-color: #d0d0d0;
    }

    .bg_highlight {
        background-color: white;
    }

  </style>
</head>
<body>

<!-- <h2>aguide-js</h2> -->


<!-- <button type="button" -->
<!-- onclick="document.getElementById('demo').innerHTML = Date()"> -->
<!-- Open AmigaGuide...</button> -->

<div id="div-input">
  <input type="file" id="input" value="" />
</div>

<div id="aguide" style="display: none;">
  <p id="demo"></p>
</div>

<script>
  function main()
  {
      const inputElement = document.getElementById("input");
      inputElement.addEventListener("change", read_input, false);
      inputElement.click();
  }

  function read_input()
  {
      const file = this.files.item(0);
      var reader = new FileReader();
      reader.addEventListener("load", () => { process_input(reader.result); },
                              false);
      reader.readAsText(file);
  }

  function process_input(text)
  {
      var ps = new_parse_state(text);
      var aguide = parse_aguide(ps);

      var input_div = document.getElementById("div-input");
      input_div.style ="display: none;";

      var aguide_div = document.getElementById("aguide");
      aguide_div.style = "display: block;";
      
      if(!aguide) {
          aguide_div.innerHTML = "Input does not appear to be AmigaGuide";
          return;
      }
      
      var t = "Parsed an AmigaGuide ${aguide.database}<br>";
      t += JSON.stringify(aguide.nodes);
      console.info(t);

      display_node(aguide, "main", aguide_div);
  }

  /******* amiga guide functions *******/
  function get_handler(handlers, name)
  {
      for(i = 0; i < handlers.length; ++i) {
          if(handlers[i].cmd === name) {
              return handlers[i].handler;
          }
      }

      return null;
  }

  function parse_aguide(ps)
  {
      var aguide = new_aguide(ps);

      if(!aguide) {
          return null;
      }

      const cmd_handlers = [
          { cmd: "@master", handler: finish_cmd_master },
          { cmd: "@node", handler: finish_cmd_node }
      ];

      var e = true;
      while(aguide && !at_eof(ps) && e === true) {
          var token = parse_state_search_token(ps, /^@\S+/m, false);
          if(!token) {
              break;
          }

          var t = token.token.toLowerCase();
          console.info("Parsed token: " + t);

          var cmd_handler = get_handler(cmd_handlers, t);
          if(cmd_handler) {
              e = cmd_handler(ps, token, aguide);
          }//  else {
          //     parse_state_consume_token(ps, token);
          // }
      }

      return aguide;
  }

  // Create a new aguide struct and parse the initial
  // `@database <name>` command
  function new_aguide(ps)
  {
      var token = get_next_token(ps, false);
      if(!token || token.token.toLowerCase() !== "@database") {
          return null;
      }

      console.info("Reading AmigaGuide: found @database");

      var db_name = get_next_token(ps, false);
      if(!db_name) {
          return null;
      }
      return {
          database: db_name.token,
          text: ps.text,
          nodes: []
      };
  }

  // token is @master, parse path
  // Return true on success, false on error
  function finish_cmd_master(ps, token, aguide)
  {
      var path = get_next_token(ps, false);
      if(!path) {
          return false;
      }
      aguide.master = path;
      console.info("  master.path = " + path);
      return true;
  }

  // token is @node, parse name, title, find @endnode
  function finish_cmd_node(ps, token, aguide)
  {
      var node = {
          name: "",
          title : "",
          start_cmd: token.start, // @ in @node
          start: -1,          // index past end of start
          end_cmd: -1,        // @ in @endnode
          end: -1             // index past end of @endnode
      };

      var name = get_next_token(ps, false);
      if(!name) {
          return false;
      }
      node.name = name.token.toLowerCase();

      var title = get_next_token(ps, false);
      if(!title) {
          return false;
      }
      node.title = title.token;
      node.start = title.end;

      var token = parse_state_search_token(ps, /^@endnode/m, false);

      if(!token) {
          return false;
      }

      node.end = token.start;
      node.end_cmd = token.end;

      var en_name = get_next_token(ps, true);
      if(en_name && en_name.token.toLowerCase()[0] != "@") {
          parse_state_consume_token(ps, en_name);
          var n = en_name.token.toLowerCase();
          if(n !== node.name) {
              console.error("Found @endnode with name " + n + " for @node name " + node.name);
          } else {
              node.end_cmd = en_name.end;
          }
      }

      // parse_state_consume_to(ps.pos, ps2.pos);
      aguide.nodes.push(node);

      return true;
  }

  function find_node(aguide, name)
  {
      for(i = 0; i < aguide.nodes.length; ++i) {
          if(aguide.nodes[i].name === name) {
              return aguide.nodes[i];
          }
      }

      return null;
  }

  /* Display node `name`, rendering to `div` */
  function display_node(aguide, name, div)
  {
      var n = find_node(aguide, name);
      if(!n) {
          return;
      }

      html = render_html(aguide, n);

      div.innerHTML = html;
      // div.innerHTML = aguide.text.slice(n.start, n.end);
  }

  /* Translate amiga guide node to HTML */
  function render_html(aguide, node)
  {
      var html = "";

      var ps = new_node_parse_state(aguide, node);

      const cmd_handlers = [
      ];
   
      var ps2 = parse_state_translate(ps,
                                      [{from: "<", to: "&lt;"},
                                       {from: ">", to: "&gt;"},
                                       {from: "\n", to: "<br>"}]);
      var render_state = {
          style: []
      };

      while(!at_eof(ps2)) {
          console.info("pos: " + ps2.pos);

          var c = parse_state_search_token(ps2, /[\\@]/, true);
          if(!c) {
              html += parse_state_slice(ps2, ps2.pos, -1, false);
              break;
          }

          html += parse_state_slice(ps2, 0, c.start - ps2.pos, false);

          if(c.token === "\\") { /* escape */
              /* Skip backslash, emit next char */
              html += parse_state_slice(ps2, 1, 2, false);
          } else if(c.token === "@") { /* start cmd */
              var brace = parse_state_search_token(ps2, /^@{[^}]*}/, true);
              if(brace) {
                  parse_state_consume_token(ps2, brace);
                  var cmd = brace.token.slice(2, -1);
                  console.log("handle @{" + cmd + "}");
                  html += render_brace_cmd(aguide, cmd, render_state);
              } else {
                  var t = get_next_token(ps2, false);
                  console.log("handle cmd " + t.token);
                  html += t.token;
              }
          }
      }

      return html;
  }

  function render_brace_cmd(aguide, cmd, render_state)
  {
      var ps = new_parse_state(cmd);
      var t = get_next_token(ps, false);
      if(!t) {
          return "";
      }

      var tlc = t.token.toLowerCase();
      if(tlc === "b" || tlc === "i" || tlc === "u") {
          var html = render_state.style.length > 0 ? "</span>" : "";
          var cls = apply_style(render_state, tlc);
          if(cls) {
              html += "<span class=\"" + cls + "\">";
          }
          return html;
      } else if(tlc === "ub" || tlc === "ui" || tlc === "uu") {
          var html = render_state.style.length > 0 ? "</span>" : "";
          var cls = remove_style(render_state, tlc);
          if(cls) {
              html += "<span class=\"" + cls + "\">";
          }
          return html;
      } else if(tlc === "fg" || tlc === "bg") {
          var color = get_next_token(ps, false);
          if(color) {
              var html = render_state.style.length > 0 ? "</span>" : "";
              var cls = apply_color(render_state, tlc, color);
              if(cls) {
                  html += "<span class=\"" + cls + "\">";
              }
              return html;
          }
      }

      return "@{" + cmd + "}";
  }

  function apply_style(render_state, cmd)
  {
      if(render_state.style.indexOf(cmd) === -1) {
          render_state.style.push(cmd);
          render_state.style.sort();
      }

      return render_state.style.join(" ");
  }

  function remove_style(render_state, cmd)
  {
      if(cmd[0] === "u") {
          render_state.style = render_state.style.filter((x) => {
              return x !== cmd[1];
          });
          render_state.style.sort();
      }

      return render_state.style.join(" ");
  }

  function apply_color(render_state, cmd, color)
  {
      render_state.style = render_state.style.filter((x) => {
          return x.indexOf(cmd) !== 0;
      });
      render_state.style.push(cmd + "_" + color.token);
      render_state.style.sort()

      return render_state.style.join(" ");
  }

  function new_node_parse_state(aguide, node)
  {
      return new_parse_state(aguide.text.slice(node.start, node.end));
  }

  /******* parse_state functions *******/
  function new_parse_state(text)
  {
      return { text: text, pos: 0 }
  }

  // function parse_state_dup(ps)
  // {
  //     return { text: ps.text, pos: ps.pos }
  // }

  function parse_state_fork(ps)
  {
      return new_parse_state(ps.text.slice(ps.pos))
  }

  function at_eof(ps)
  {
      return ps.pos >= ps.text.length
  }

  // peek: if true, don't update parse state
  function get_next_token(ps, peek)
  {
      var pos = ps.pos;

      // skip to first not-whitespace
      var next_ws = ps.text.slice(pos).search(/\S/);
      if(next_ws === -1) {
          return null;
      }

      pos += next_ws;

      var begins_line = false;
      if(pos > 0 && ps.text[pos - 1] == '\n') {
          begins_line = true;
      }

      var next_re = /\s/;
      var quoted = 0;
      // If current char is double quote, token is all text up to matching
      // quote.
      if(ps.text[pos] === '"') {
          next_re = /"/;
          quoted = 1;
      }

      var next = ps.text.slice(pos + quoted).search(next_re);
      if(next === -1) {
          /* token is all text to end */
          var token = ps.text.slice(pos);
          var end = pos + token.length;
          if(peek === false) {
              parse_state_consume_to(ps, end);
          }
          return new_token(token, pos, end, begins_line);
      }

      next += quoted * 2;
      var token = ps.text.slice(pos, pos + next);
      var end = pos + next;
      if(peek === false) {
          parse_state_consume_to(ps, end);
      }
      return new_token(token, pos, end, begins_line);
  }

  function new_token(token, start, end, begins_line)
  {
      return { token: token, start: start, end: end, begins_line: begins_line };
  }

  function parse_state_slice(ps, start, end, peek)
  {
      if(end !== -1) {
          var t = ps.text.slice(ps.pos + start, ps.pos + end);
          if(peek === false) {
              parse_state_consume_to(ps, ps.pos + end);
          }
          return t;
      }
      var t = ps.text.slice(ps.pos + start);
      if(peek === false) {
          parse_state_consume_to(ps, ps.text.length);
      }
      return t;
  }

  function parse_state_search_token(ps, re, peek)
  {
      var pos = ps.pos;
      var start = ps.text.slice(pos).search(re);
      if(start === -1) {
          return null;
      }

      var token = ps.text.slice(pos).match(re);
      if(token.length <= 0) {
          return null;
      }
      var end = pos + start + token[0].length;

      if(peek === false) {
          parse_state_consume_to(ps, end);
      }

      return new_token(token[0], pos + start, end, false);
  }

  function parse_state_consume_token(ps, token)
  {
      ps.pos = token.end;
  }

  function parse_state_consume_to(ps, end)
  {
      ps.pos = end;
  }

  // trs: array of objects {from: x, to: y}
  //      x: string or regex to replace
  //      y: replacement
  function parse_state_translate(ps, trs)
  {
      var ps2 = parse_state_fork(ps);
      trs.forEach((tr) => {
          ps2.text = ps2.text.replaceAll(tr.from, tr.to);
      });

      return ps2;
  }

  main();
</script>

</body>
</html> 
