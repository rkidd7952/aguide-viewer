<!DOCTYPE html>
<html>
<meta charset="iso-8859-1" />
<title>aguide-js</title>
<body>

<!-- <h2>aguide-js</h2> -->


<!-- <button type="button" -->
<!-- onclick="document.getElementById('demo').innerHTML = Date()"> -->
<!-- Open AmigaGuide...</button> -->

<div id="div-input">
  <input type="file" id="input" value="" />
</div>

<div id="aguide" style="display: none;">
  <p id="demo"></p>
</div>

<script>
  function main()
  {
      const inputElement = document.getElementById("input");
      inputElement.addEventListener("change", read_input, false);
      inputElement.click();
  }

  function read_input()
  {
      const file = this.files.item(0);
      var reader = new FileReader();
      reader.addEventListener("load", () => { process_input(reader.result); },
                              false);
      reader.readAsText(file);
  }

  function process_input(text)
  {
      var ps = new_parse_state(text);
      var aguide = parse_aguide(ps);

      var input_div = document.getElementById("div-input");
      input_div.style ="display: none;";

      var aguide_div = document.getElementById("aguide");
      aguide_div.style = "display: block;";
      
      if(!aguide) {
          aguide_div.innerHTML = "Input does not appear to be AmigaGuide";
          return;
      }
      
      var t = "Parsed an AmigaGuide ${aguide.database}<br>";
      t += JSON.stringify(aguide.nodes);
      console.info(t);

      display_node(aguide, "main", aguide_div);
  }

  /******* amiga guide functions *******/
  function get_handler(handlers, name)
  {
      for(i = 0; i < handlers.length; ++i) {
          if(handlers[i].cmd === name) {
              return handlers[i].handler;
          }
      }

      return null;
  }

  function parse_aguide(ps)
  {
      var aguide = new_aguide(ps);

      if(!aguide) {
          return null;
      }

      const cmd_handlers = [
          { cmd: "@master", handler: finish_cmd_master },
          { cmd: "@node", handler: finish_cmd_node }
      ];

      var e = true;
      while(aguide && !at_eof(ps) && e === true) {
          var token = parse_state_search_token(ps, /^@\S+/m, false);
          if(!token) {
              break;
          }

          var t = token.token.toLowerCase();
          console.info("Parsed token: " + t);

          var cmd_handler = get_handler(cmd_handlers, t);
          if(cmd_handler) {
              e = cmd_handler(ps, token, aguide);
          }//  else {
          //     parse_state_consume_token(ps, token);
          // }
      }

      return aguide;
  }

  // Create a new aguide struct and parse the initial
  // `@database <name>` command
  function new_aguide(ps)
  {
      var token = get_next_token(ps, false);
      if(!token || token.token.toLowerCase() !== "@database") {
          return null;
      }

      console.info("Reading AmigaGuide: found @database");

      var db_name = get_next_token(ps, false);
      if(!db_name) {
          return null;
      }
      return {
          database: db_name.token,
          text: ps.text,
          nodes: []
      };
  }

  // token is @master, parse path
  // Return true on success, false on error
  function finish_cmd_master(ps, token, aguide)
  {
      var path = get_next_token(ps, false);
      if(!path) {
          return false;
      }
      aguide.master = path;
      console.info("  master.path = " + path);
      return true;
  }

  // token is @node, parse name, title, find @endnode
  function finish_cmd_node(ps, token, aguide)
  {
      var node = {
          name: "",
          title : "",
          start_cmd: token.start, // @ in @node
          start: -1,          // index past end of start
          end_cmd: -1,        // @ in @endnode
          end: -1             // index past end of @endnode
      };

      var name = get_next_token(ps, false);
      if(!name) {
          return false;
      }
      node.name = name.token.toLowerCase();

      var title = get_next_token(ps, false);
      if(!title) {
          return false;
      }
      node.title = title.token;
      node.start = title.end;

      var token = parse_state_search_token(ps, /^@endnode/m, false);

      if(!token) {
          return false;
      }

      node.end = token.start;
      node.end_cmd = token.end;

      var en_name = get_next_token(ps, true);
      if(en_name && en_name.token.toLowerCase()[0] != "@") {
          parse_state_consume_token(ps, en_name);
          var n = en_name.token.toLowerCase();
          if(n !== node.name) {
              console.error("Found @endnode with name " + n + " for @node name " + node.name);
          } else {
              node.end_cmd = en_name.end;
          }
      }

      // parse_state_consume_to(ps.pos, ps2.pos);
      aguide.nodes.push(node);

      return true;
  }

  function find_node(aguide, name)
  {
      for(i = 0; i < aguide.nodes.length; ++i) {
          if(aguide.nodes[i].name === name) {
              return aguide.nodes[i];
          }
      }

      return null;
  }

  /* Display node `name`, rendering to `div` */
  function display_node(aguide, name, div)
  {
      var n = find_node(aguide, name);
      if(!n) {
          return;
      }

      html = render_html(aguide, n);

      div.innerHTML = html;
      // div.innerHTML = aguide.text.slice(n.start, n.end);
  }

  /* Translate amiga guide node to HTML */
  function render_html(aguide, node)
  {
      var html = "";

      var ps = new_node_parse_state(aguide, node);

      const cmd_handlers = [
      ];
   
      html = aguide.text.slice(node.start, node.end)
      html = html.replaceAll("<", "&lt;");
      html = html.replaceAll(">", "&gt;");
      return html;

      while(!at_eof(ps)) {
          console.info("pos: " + ps.pos);

          var c = parse_state_search_token(ps, /[\@]/, true);
          if(!c) {
              html += parse_state_slice(ps, 0, -1, false);
              break;
          }

          html += parse_state_slice(ps, 0, c.start, false);

          if(c.token === "\\") { /* escape */
              /* Skip backslash, emit next char */
              html += parse_state_slice(ps, 1, 2, false);
          } else if(c.token === "@") { /* start cmd */
              var brace = parse_state_search_token(ps, /@{[^}*]}/, false);
              if(brace) {
                  console.log("handle @{" + brace.token.slice(2, -1) + "}")
              } else {
                  var t = get_next_token(ps, false);
                  console.log("handle cmd " + t.token);
              }
          }
          

          // var token = get_next_token(ps, true);
          // if(!token) {
          //     html += parse_state_slice(ps, 0, -1, false);
          //     break;
          // }

          // var handler = get_handler(cmd_handlers, token.token.toLowerCase());
          // if(handler) {
          //     console.log("Do something with cmd " + token.token);
          // } else if(token.token.indexOf("@{") === 0) {
          //     /* handle @{...} */
          //     var at_end = parse_state_search_token(ps, /}/, false);

              
          // }

          // html += parse_state_slice(ps, 0, -1, false);
          

          // var next_at = parse_state_search_token(ps, /@{/, false);
          // if(!next_at) {
          //     html += parse_state_slice(ps, 0, -1, false);
          //     break;
          // }

          // html += parse_state_slice(ps, 0, next_at.start, false);

          // var at_end = parse_state_search_token(ps, /}/, false);
      }

      return html;
  }

  function new_node_parse_state(aguide, node)
  {
      return new_parse_state(aguide.text.slice(node.start, node.end));
  }

  /******* parse_state functions *******/
  function new_parse_state(text)
  {
      return { text: text, pos: 0 }
  }

  function dup_parse_state(ps)
  {
      return { text: ps.text, pos: ps.pos }
  }

  function at_eof(ps)
  {
      return ps.pos >= ps.text.length
  }

  // peek: if true, don't update parse state
  function get_next_token(ps, peek)
  {
      var pos = ps.pos;

      // skip to first not-whitespace
      var next_ws = ps.text.slice(pos).search(/\S/);
      if(next_ws === -1) {
          return null;
      }

      pos += next_ws;

      var begins_line = false;
      if(pos > 0 && ps.text[pos - 1] == '\n') {
          begins_line = true;
      }

      var next_re = /\s/;
      var quoted = 0;
      // If current char is double quote, token is all text up to matching
      // quote.
      if(ps.text[pos] === '"') {
          next_re = /"/;
          quoted = 1;
      }

      var next = ps.text.slice(pos + quoted).search(next_re);
      if(next === -1) {
          return null;
      }

      next += quoted * 2;
      var token = ps.text.slice(pos, pos + next);
      var end = pos + next;
      if(peek === false) {
          parse_state_consume_to(ps, end);
      }
      return new_token(token, pos, end, begins_line);
  }

  function new_token(token, start, end, begins_line)
  {
      return { token: token, start: start, end: end, begins_line: begins_line };
  }

  function parse_state_slice(ps, start, end, peek)
  {
      if(end !== -1) {
          var t = ps.text.slice(ps.pos + start, ps.pos + end);
          if(peek === false) {
              parse_state_consume_to(ps.pos, end);
          }
          return t;
      }
      var t = ps.text.slice(ps.pos + start);
      if(peek === false) {
          parse_state_consume_to(ps, ps.text.length);
      }
      return t;
  }

  function parse_state_search_token(ps, re, peek)
  {
      var pos = ps.pos;
      var start = ps.text.slice(pos).search(re);
      if(start === -1) {
          return null;
      }

      var token = ps.text.slice(pos).match(re);
      if(token.length <= 0) {
          return null;
      }
      var end = pos + start + token[0].length;

      if(peek === false) {
          parse_state_consume_to(ps, end);
      }

      return new_token(token[0], pos + start, end, false);
  }

  function parse_state_consume_token(ps, token)
  {
      ps.pos = token.end;
  }

  function parse_state_consume_to(ps, end)
  {
      ps.pos = end;
  }

  main();
</script>

</body>
</html> 
